# Develop Windows Store Apps

## Create background tasks

* A background task implements the `IBackgroundTask` interface, which defines a `Run` method with the signature 
```
public void Run(IBackgroundTaskInstance taskInstance)
```
* You can later use this task with the `BackgroundTaskBuilder` class:
```
var builder = new BackgroundTaskBuilder();
builder.Name = taskName;
builder.TaskEntryPoint = "BikeGPS.BikePositionUpdateBackgroundTask";
```
* Also, you need to set a trigger for when the background task will run:
```
builder.SetTrigger(new SystemTrigger(SystemTriggerType.TimeZoneChange, false));
```
* Possible triggers are `Invalid, SMSReceived, UserAway, NetworkStateChange, ControlChannelReset, InternetAvailable, SessionConnected, ServicingComplete, LockScreenApplicationRemoved, TimeZoneChange, OnlineIdConnectedStateChange`
* An application that registers a background task needs to declare the feature as an extension in the application manifest. The extension section needs to be inserted as a child of the Application tag.
```
<Extensions>
 <Extension Category="windows.backgroundTasks" EntryPoint="Namespace.MyBackgroundTask">
  <BackgroundTasks>
   <Task Type="systemEvent" />
  </BackgroundTasks>
 </Extension>
</Extensions>
```
* The Visual Studio App Manifest Designer can also be used to add a Background Tasks declaration, the details of which can then be edited in a graphical interface.
* To check if a task is active, one can look for it by name through the `BackgroundTaskRegistration.AllTasks` enumerable. An individual item's `task.Value.Name` property can be compared to the locally stored task name.
* For tasks that perform asynchronous work, the Run method needs to return a deferral
```
public async void Run(IBackgroundTaskInstance taskInstance)
{
 BackgroundTaskDeferral _deferral = taskInstance.GetDeferral();

 await MyWorkMethodAsync();
 _deferral.Complete();
}
```
## Consume background tasks

### Understanding task triggers and conditions

* Tasks respond to different kinds of triggers. These can be
 * `MaintenanceTrigger` - raised when it's time to execute system maintenance tasks
 * `SystemEventTrigger` - raised when a specific system event occurs
* Both of these types of triggers implement the `IBackgroundTask` interface
* A `MaintenanceTrigger` is created via
```
var myTaskTrigger = new MaintenanceTrigger(60, true)
```
 * The first parameter is the freshness time, expressed in minutes
 * The second parameter indicates if the trigger should fire only once, or on every freshness time occurence

* Whenever a system event occurs, we can check if specific conditions are met to see if our background task should be performed. These conditions are listed in the `SystemConditionType` enum
 * `InternetAvailable`
 * `InternetNotAvailable`
 * `SessionConnected`
 * `SessionNotConnected`
 * `UserNotPresent`
 * `UserPresent`

* The maintenance trigger can schedule a background task once every 15 minutes, if the device is plugged into a power source, but it will not fire when the device runs on battery.

* An application that makes use of the lock-screen features can also make use of several other triggers
 * `PushNotificationTrigger`- raised when a notificationa arrives on the Windows Push Notification Service channel
 * `TimeTrigger` - raised on scheduled intervals, as frequentyl as once every 15 minutes
 * `ControlChannelTrigger` - raised when there are incomming messages on the control channel for applications that keep connections alive
* The user must place the application on the lock screen before it can access triggers. This can be done with the `RequestAccessAsync` method. The following conditions are available to lock screen enabled applications:
 * ControlChannelReset
 * SessionConnected
 * UserAway
 * UserPresent
* There are two related , self-explanatory events here - `LockScreenApplicationAdded` and `LockScreenApplicationRemoved`
* Time triggered tasks are defined similarly to maintenace triggered tasks
```
TimeTrigger myTaskTrigger = new TimeTrigger(60, true);
```
* Note that if the runOnce flag is set to false, the first time the trigger fires will be at the next, fixed 15 minute interval, meaning sometime between now and in 15 minutes. If it's set to fire only once, then it will fire at exactly 15 minutes after registration time.

### Progressing through and completing background tasks
To get the result of a task execution, the application can provide a callback for the `OnCompleted` event. The callback will receive an instance of a `BackgroundTaskRegistration` initially used to register the task and the event arguments.
```
var builder = new BackgroundTaskBuilder();
builder.name = taskName;
builder.TaskEntryPoint = "MyNamespace.MyBackgroundTask";
builder.SetTrigger(new SystemTrigger(SystemTrigger.Type.TimeZoneChange, false));
builder.AddCondition(new SystemCondition(SystemConditionType.InternetAvailable));
BackgroundTaskRegistration taskRegistration = builder.Register();
taskRegistration.Completed += myCallbackHandler;

void myCallbackHandler(BackgroundTaskRegistration sender, BackgroundTaskCompletedEventArgs args) {
 if (sender.Name == "MyNamespace.MyBackgroundTask") {
  // do stuff
 }
}
```
