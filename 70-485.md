# Develop Windows Store Apps

## Create background tasks

* A background task implements the `IBackgroundTask` interface, which defines a `Run` method with the signature 
```
public void Run(IBackgroundTaskInstance taskInstance)
```
* You can later use this task with the `BackgroundTaskBuilder` class:
```
var builder = new BackgroundTaskBuilder();
builder.Name = taskName;
builder.TaskEntryPoint = "BikeGPS.BikePositionUpdateBackgroundTask";
```
* Also, you need to set a trigger for when the background task will run:
```
builder.SetTrigger(new SystemTrigger(SystemTriggerType.TimeZoneChange, false));
```
* Possible triggers are `Invalid, SMSReceived, UserAway, NetworkStateChange, ControlChannelReset, InternetAvailable, SessionConnected, ServicingComplete, LockScreenApplicationRemoved, TimeZoneChange, OnlineIdConnectedStateChange`
* An application that registers a background task needs to declare the feature as an extension in the application manifest. The extension section needs to be inserted as a child of the Application tag.
```
<Extensions>
 <Extension Category="windows.backgroundTasks" EntryPoint="Namespace.MyBackgroundTask">
  <BackgroundTasks>
   <Task Type="systemEvent" />
  </BackgroundTasks>
 </Extension>
</Extensions>
```
* The Visual Studio App Manifest Designer can also be used to add a Background Tasks declaration, the details of which can then be edited in a graphical interface.
* To check if a task is active, one can look for it by name through the `BackgroundTaskRegistration.AllTasks` enumerable. An individual item's `task.Value.Name` property can be compared to the locally stored task name.
* For tasks that perform asynchronous work, the Run method needs to return a deferral
```
public async void Run(IBackgroundTaskInstance taskInstance)
{
 BackgroundTaskDeferral _deferral = taskInstance.GetDeferral();

 await MyWorkMethodAsync();
 _deferral.Complete();
}
```
## Consume background tasks

### Understanding task triggers and conditions

* Tasks respond to different kinds of triggers. These can be
 * `MaintenanceTrigger` - raised when it's time to execute system maintenance tasks
 * `SystemEventTrigger` - raised when a specific system event occurs
* Both of these types of triggers implement the `IBackgroundTask` interface
* A `MaintenanceTrigger` is created via
```
var myTaskTrigger = new MaintenanceTrigger(60, true)
```
 * The first parameter is the freshness time, expressed in minutes
 * The second parameter indicates if the trigger should fire only once, or on every freshness time occurence

* Whenever a system event occurs, we can check if specific conditions are met to see if our background task should be performed. These conditions are listed in the `SystemConditionType` enum
 * `InternetAvailable`
 * `InternetNotAvailable`
 * `SessionConnected`
 * `SessionNotConnected`
 * `UserNotPresent`
 * `UserPresent`

* The maintenance trigger can schedule a background task once every 15 minutes, if the device is plugged into a power source, but it will not fire when the device runs on battery.

* An application that makes use of the lock-screen features can also make use of several other triggers
 * `PushNotificationTrigger`- raised when a notificationa arrives on the Windows Push Notification Service channel
 * `TimeTrigger` - raised on scheduled intervals, as frequentyl as once every 15 minutes
 * `ControlChannelTrigger` - raised when there are incomming messages on the control channel for applications that keep connections alive
* The user must place the application on the lock screen before it can access triggers. This can be done with the `RequestAccessAsync` method. The following conditions are available to lock screen enabled applications:
 * ControlChannelReset
 * SessionConnected
 * UserAway
 * UserPresent
* There are two related , self-explanatory events here - `LockScreenApplicationAdded` and `LockScreenApplicationRemoved`
* Time triggered tasks are defined similarly to maintenace triggered tasks
```
TimeTrigger myTaskTrigger = new TimeTrigger(60, true);
```
* Note that if the runOnce flag is set to false, the first time the trigger fires will be at the next, fixed 15 minute interval, meaning sometime between now and in 15 minutes. If it's set to fire only once, then it will fire at exactly 15 minutes after registration time.

### Progressing through and completing background tasks
To get the result of a task execution, the application can provide a callback for the `OnCompleted` event. The callback will receive an instance of a `BackgroundTaskRegistration` initially used to register the task and the event arguments.
```
var builder = new BackgroundTaskBuilder();
builder.name = taskName;
builder.TaskEntryPoint = "MyNamespace.MyBackgroundTask";
builder.SetTrigger(new SystemTrigger(SystemTrigger.Type.TimeZoneChange, false));
builder.AddCondition(new SystemCondition(SystemConditionType.InternetAvailable));
BackgroundTaskRegistration taskRegistration = builder.Register();
taskRegistration.Completed += myCallbackHandler;

void myCallbackHandler(BackgroundTaskRegistration sender, BackgroundTaskCompletedEventArgs args) {
 if (sender.Name == "MyNamespace.MyBackgroundTask") {
  // do stuff
 }
}
```

A background task can be executed when the application is suspended or even terminated. The `OnCompleted` callback will fire then the application resumes or is re-launched. To see the result of a task execution, we can check `args.CheckResult()` It will throw an error if something went wrong.

There is also the `OnProgress` event. A task can set the progress in the `Run()` method through the `Progress` property of the `IBackgroundTask` instance.

### Understanding task constraints
**A background task needs to be ligthweight**. The CPU time for applications not on the lock screen is limited to 1 second. The task can run every 2 hours at a minimum. For applications on the lock screen, the CPU time is limited to 2 seconds and it can run at a maximum interval of 15 minutes.

As for network time, there's a usage limit based on the amount of energy used by the network card when the app is using it.This can vary depending on the device.

To prevent these quotas from affecting real-time communication apps, tasks using `ControlChannelTrigger` and `PushNotificationTrigger` receive a guaranteeed resource quota. If the task exceeds these quotas, it's suspended by the runtime. The `SuspendedCount` property can be checked on the `IBackgroundTask` instance in the `Run` method.

### Cancelling a task
An executing task cannot be stopped unless it recognizes a cancellation request. This has to be checked in the `Run` method.The best way to do this is to attach an `OnCanceled` handler to the `Cancel` event of the task and then set a `volatile bool` private property to `true` in the handler. The `Run` method can then check the private property and `return` if it's set to true.

If the task wants to communicate some data to the application, it can use the local persistent storage to do that, which the application can then check.

### Updating a background task
Tasks can "live through" application updates. If the aplication needs to update a task to modify its behavior, it can register a background task with the 'ServicingComplete' trigger. This task can then unregister no-longer valid tasks:
```
var task = FindTask("MyNameSpace.MyTask")
if (task != null) task.Unregister(true);
```
